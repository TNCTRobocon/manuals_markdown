# 計算量

## 計算量とは

アルゴリズムでどのくらい計算したら結果が出るかについての指標の一つである

## O記法

オーダー記法、オー記法と言われる  
ランダヴの記号とも呼ばれている

O(n) のように記述する

## 計算量オーダー

O(n) や O(1), O(log x), O(n log n) などのように書く

ざっくりと説明すると、それぞれの意味はアルゴリズムの入力をnとして、  
nに比例した回数の計算ステップ(O(n))、  
n^2に比例した計算ステップ(O(n^2))  
log nに比例した計算ステップなどを表す(O(log n))

例えば

```c++
for (int i = 0; i < n; i++){
    //何らかの処理
}
```

だと計算量はO(n)

```c++
for (int i = 0; i < n;i++){
    for (int j = 0; j < m; j++{
        //何らかの処理
    })
}
```

この場合のアルゴリズムはO(n^2)となる

## 計算量の書き方

現実的に考えてさっきのコードのようなきれいな計算回数が出てくることは多くはないだろう

なので適当な計算例で考えてみる

計算回数が  
2n^2 + 50n + 150  
とする

- step 1 最高次数以外の項を落とす  
2n^2 + 50n + 150 → 2n^2

- step 2 係数を無視する  
2n^2 → n^2

という風にして大体n^2に比例する計算時間を要するO(n^2)のアルゴリズムと考える

step 1の理由  
nが大きくなっていくと、次数が大きいほうが圧倒的に大きくなるため、いずれほとんど無視できるようになるから

step 2の理由  
係数考えるより次数下げたほうが遥かに効果あるし係数あると考えるのが難しくなるから

以上の理由で計算量がこのようになることがわかる

## 計算量の大まかな数値

こう見ると大きな差が出ているのがわかる

|log{n}|**n**|nlog{n}|n^2|n^3|2^n|n!|
|---|---|---|---|---|---|---|
|2|**5**|12|25|130|30|120|
|3|**10**|33|100|1,000|1,024|3,628,800|
|4|**15**|59|225|3.375|32,768|-|
|4|**20**|86|400|8,000|1,048,576|-|
|5|**25**|116|625|15,625|-|-|
|5|**30**|147|900|27,000|-|-|
|7|**100**|664|10,000|1,000,000|-|-|
|8|**300**|2,468|90,000|27,000,000|-|-|
|10|**1,000**|9,966|1,000,000|-|-|-|
|13|**10,000**|132,877|100,000,000|-|-|-|
|16|**100,000**|1,660,964|-|-|-|-|
|20|**1,000,000**|19,931,568|-|-|-|-|

計算量の表のコピー元  
[計算量オーダーの求め方を総整理！ 〜 どこから log が出て来るか 〜](https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0)

## 代表的なアルゴリズムの計算量

### 線形探索

O(n)  
配列から数字を探す操作など

```c++
for(int i = 0; i < n; i++){
    if(array[i] == 0){
        break;
    }
}
```

### 偶数出力

O(n)  
みんなやったことある偶数だと～～するみたいなやつ

### 掛け算(九九)

O(n^2)  
九九を出力仕様としたりするとこうなる

### 行列の乗算

O(n^3)  
二年生以上はできる行列の乗算

### 二進法展開

O(log n)
10進数を二進数に直す計算

```C++
int n;//任意の自然数

while(n){
    if(n % 2 == 0){
        std::cout << 0;
    }else {
        std::cout << 1;
    }
    n /= 2;
}
```

### 二分探索

O(log n)  
配列aの中に値があるか確かめるなどの操作  

詳しくは自分で調べて見てください(もしかしたらマニュアルで書くかも)

### マージソート

O(n log n)  
O(n log n)の代表的なアルゴリズム  
並び替えに使われる

こちらも機会があれば別で書く

### 素数判定

O(\sqrt n)  
nが素数かどうかを判定する  

計算量がnではないのは平方根の2乗まで調べれば、これ以上やってもかける数とかけられる数の大小が入れ替わるだけであり、自然数の積は入れ替えることができることからそれ以上調べる必要がないことを理解してほしい

## c++で使う計算量

### array, vectorのコピー

O(n)  
実際、コピーの方法はあまり配列と変わらない  
二次元配列になると計算量はO(n^2)、三次元配列になると計算量はO(n^3)になる

2021/12/03  
writen by 西永
