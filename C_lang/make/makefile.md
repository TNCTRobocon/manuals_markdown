# makefile講座

## コンパイルを楽にするために

C言語のコラムでファイル分割したときのコンパイルやビルドオプションを紹介した  
これらを毎回コマンドラインに打ち込むのは苦痛だろう

`makefile`を利用して楽になろう

## makefileの使い方

### makeの基本

[作りたいもの] : [材料]
(--TAB--) [作り方]

まず、`C_lang`の最後に出てきた例のファイルをコンパイルすることを考える

```sh
$ gcc -c main.c
$ gcc -c hoge.c
$ gcc main.o hoge.o -o main 
```

この順でコンパイルしよう

え？ `gcc -o main main.c hoge.c`ってすればいいって？

これだと毎回全ファイルをコンパイルしてしまって効率が悪いので今回は上のコンパイル方法で生成した

```makefile
main: main.o hoge.o
    gcc main.o hoge.o -o main

main.o: main.c
    gcc -c main.c

hoge.o: hoge.c
    gcc -c hoge.c
```

```sh
$ make main
```

とすれば実行できる

また、

```sh
$ make
```

とすると一番上のものを実行するので今回は`make`と`make main`は同じ動きをする

注意として最初に空白がある時はtab出なければ正しい動きをしないので注意

#### makeとしたときの挙動

`main.o`や`hoge.o`が存在すればそれを用いてリンクを行い、実行ファイルを作る

`main.o`や`hoge.o`が存在しない、またはその材料の`main.c`や`hoge.c`の方が更新した日付が新しければそちらをコンパイルしてオブジェクトファイルを作る

うーん便利

### 変数の記述

実際にこうやって作られているかといわれればそうではない

変数を使ってもっと賢く`makefile`を書いている  
~~説明する内容が変数だけじゃないのは内緒~~

```makefile
TARGET  ?= main
CC      ?= gcc
CFLAGS  ?= -Wall -O2 -std=c17
SRCS    ?= main.c hoge.c
OBJS    ?= $(SRCS:%.c=%.o)
INC     ?= 
LIBS    ?= 
LDFLAGS ?= 
.PHONY: all clean

all: $(TARGET)
$(TARGET): $(OBJS)
    $(CC) $^ -o $@ $(CFLAGS) $(INC) $(LIBS) $(LDFLAGS)

.c.o:
    $(CC) -c $^ $(CFLAGS) $(INC) $(LIBS) $(LDFLAGS) 

clean:
    rm -f *exe *.o
```

上から説明していくよ

### 変数

`TARGET`とか`CC`とかのこと  
`=`を付けることによって宣言、定義を行い、呼び出し方としては`$([variable])`のようにドルマークをつけそのあとに括弧をつけその中に記述する

慣例として大文字で変数名は記述する

### 自動変数

`$@`とか`$^`とかのこと  

```makefile
ターゲット: 依存するファイル
    コマンド
```

とすると

- `$@` : ターゲットファイル名
- `$^` : すべての依存するファイル名
- `$<` : 最初の依存するファイル名
- `$?` : ターゲットより新しいすべての依存するファイル名
- `$*` : サフィックス(サフィックスについては後述)を除いたターゲット名

だいぶ楽に書けるようになった

### サフィックスルール

ターゲットファイルとソースファイルの間のサフィックス(拡張子)のみが異なり、かつサフィックスの関係だけで行うべきコマンドが決まる場合にまとめて記述できるルール

```makefile
.c.o: 
    $(CC) -o $^ $(CFLAG)
```

### マクロの置換

```makefile
OBJS = $(SRCS:%.c=%.o)
```

`%`記号によるマクロの置換が行われる  
今回の内容的には`SRCS`のファイルの拡張子の`.c`がすべて`.o`に置き換わる

### .PHONY

疑似ターゲット

実はmakefileは今いるディレクトリにサブコマンドと同じ名前のファイルがあるとその名前のmakeを実行してもターゲットは最新ですというエラーが出てしまう

ここでこのルールを使うと必ずコマンドが実行されるようになる

## よく使われるターゲット名

今回は`all`, `clean`が書かれているが、ほかにも`install`, `uninstall`が有名である  

## = と := と ?=

makefileでは`=`の扱いが少し特殊だ

### =

再帰的な定義をする

>再帰的とは自分自身で自分自身を定義すること  
多分初見で読んだときはなんだそれって感じだと思うけどそんなもの

```mk
X = meow
Y = cat $(X)
X = nya-n

.PHONY: cat

cat:
    @echo $(X)
    @echo $(Y)
```

出力は

```sh
nya-n
cat nya-n
```

とりあえず`Y = cat $(X)`って定義されたYはXが更新されると中身も更新されると覚えるとよい

### :=

```mk
X := meow
Y := cat $(X)
X := nya-n

.PHONY: cat

cat:
    @echo $(X)
    @echo $(Y)
```

出力は

```sh
nya-n
cat meow
```

多分皆が思う代入に一番近いと思う  
これが一番直観的だと思われる

### ?=

```mk
X ?= meow
Y ?= cat $(X)
X ?= nya-n

.PHONY: cat

cat:
    @echo $(X)
    @echo $(Y)
```

出力は

```sh
meow
cat meow
```

未定義のときにのみ代入を行う演算子

## 関数

要望があれば詳しく書く

簡単に言うと文字列をいじくるための関数が用意されている

例としては
`subst`      : 置換動作  
`findstring` : 文字列をさがす

などなど様々な関数がある

## -jx

コンパイルをCPUで平行して行うことによって高速にしようというオプション

`make -j4` のようにjの後にジョブ数を書く  
ジョブ数は並行処理の個数のことで**CPUの数*2**くらいが有効らしい
