# 多重継承

## 単一継承と多重継承

今まで扱ってきた継承は基底クラスが一つだけの継承であった  
これを単一継承といい、よく使われる継承である

これに対して基底クラスを複数指定して行う継承を多重継承という

```C++
class base_a{
public:

};

class base_b{
public:

};

class derived : public base_a, private base_b{

};
```

中身の処理を書いていないがそれは許してほしい

サンプルコードのderivedクラスはbase_aとbase_bを基底とするクラスである

### ダイヤモンド継承

C++では派生クラスから派生クラスを作ることをできる

これを孫クラスともいう(親クラス、子クラスという言い方があるから)~~その下にひ孫クラスとか玄孫クラスとかできるのだろうか~~

```C++
#include<iostream>

class Base{
public:
    void print_b(){
        std::cout<<"base"<<std::endl;
    }
};

class DerivedA : public Base{
    void print_da(){
        std::cout<<"base"<<std::endl;
    }
};

class DerivedB : public Base{
    void print_db(){
        std::cout<<"base"<<std::endl;
    }
};

class DerivedX : public DerivedA, public DerivedB{
    void print_dx(){
        std::cout<<"base"<<std::endl;
    }
};
```

[diamond_inheritance](../img/diamond1.png)

このような形になることをダイヤモンド(菱形)継承と呼ぶ

### ダイヤモンド継承の注意点

- Baseクラスの実体が二つある

これはDerivedAとDerivedBはそれぞれインスタンスを生成され、それぞれが基底クラスのインスタンスを作ると考えたら納得がいくと思う

基底クラスのメソッドを使うとDerivedA, DerivedBのどちらから基底クラスのメソッドを呼び出したのかがわからずエラーになる

こういう時はスコープ解決演算子を使うと解決する

```C++
//さっきのクラスの定義

int main(){
    DerivedX dx;

    dx.print_b();//error

    dx.DerivedA::print_da();
    dx.DerivedB::print_db();
}
```

これでエラーになることなくメソッドを呼び出せる

また、この親クラスはそれぞれ別物のクラスなので親クラスのメンバ変数にそれぞれ別の値を代入するとそれぞれ別の値が代入される

### 仮想継承

親クラスの実体を一つにできる

```C++
#include<iostream>

class Base{
public:
    void print_b(){
        std::cout<<"base"<<std::endl;
    }
};

class DerivedA : public virtual Base{
    void print_da(){
        std::cout<<"base"<<std::endl;
    }
};

class DerivedB : public virtual Base{
    void print_db(){
        std::cout<<"base"<<std::endl;
    }
};

class DerivedX : public DerivedA, public DerivedB{
    void print_dx(){
        std::cout<<"base"<<std::endl;
    }
};
```

これで親クラスのインスタンスが一つだけ生成されるようになったため、どの親クラスのメンバ変数を書き換えても同じ一つの実体の動作になる

## SOLID原則

オブジェクト指向を使うときには守りたい原則

これを守ることで変更しやすい、理解しやすい、再利用しやすいモジュール(クラスや関数などのソフトウェアを構成する部品)を設計・開発することができる

S : Single Responsibility → 単一責任の原則  
O : Open-Closed →オープンクローズドの原則  
L : Liskov Substitution → リスコフの置換原則  
I : Interface Segregation → インターフェース分離の原則  
D : Dependency Inversion → 依存性逆転の法則  

### 単一責任の原則

変更の結果としてバグが発生したとしても他の無関係な動作に影響を与えないように動作を分離することを目的としている

クラスに多くの責任(役割)があるとバグがある可能性が高くなる  
一つ変更を加えると知らないうちに他の責任に影響を与える可能性が出てくるのでバグの可能性が上がる

### オープンクローズド(解放閉鎖)の原則

そのクラスでバグが発生するのを避けるため、クラスの既存の動作を変更することなくクラスの動作を拡張することを目的としている  

クラスの動作を変更するとそのクラスを使うすべてのシステムに影響を与えてしまう  
クラスでより多くの機能を実行したいとき、理想的な方法は既存の関数に追加することであって*変更することではない*

### リスコフの置換原則

基底クラスやその派生クラスがエラーなしで同じ方法で使用できるように一貫性を保つのを目的としている

子クラスが親クラスと同じ機能を持たなくてはならないという原則  
正しいis-a関係を示すための原則でありそれを継承するのかどうかの指針になる

### インターフェース分離の原則

動作セットをより小さくして、クラスが必要なもののみを実行することを目的としている

クラスに使用しない動作を実行使用とさせるのは、無駄が多く、クラスにその動作を実行する機能がない場合、予期しないバグが発生する可能性がある

クラスはその責任を果たすために必要な動作のみを実行する必要がある  
それ以外の動作は完全に削除するか、将来的に他のクラスで使う予定がある場合は他の場所に移すべきであるということ

### 依存性逆転の法則

インターフェースを導入することによって上位のクラスが下位のクラスに依存するのを減らす目的

この原則ではクラスが動作を実行するために使用するツールと融合するべきではなく、むしろツールがクラスに接続できるようにインターフェースと融合するべきである

また、クラスもインターフェースもツールの動作を知るべきではない  
ただし、ツールはインターフェースの仕様を満たす必要がある

## 多重継承ってどうなの？

そもそも名前が衝突する可能性があり、避けられる傾向にあると

多重継承はこれら(特にリスコフの置換原則)を守れない可能性が高まるので嫌われる傾向にあるようである

多重継承を認めている言語はC++やpythonなどがある  
認めていない言語としてはC#やjavaが上げられる(C#はMix-inは許可されたっぽい)

このように言語の時点で禁止されることもある機能なので使うかどうかは考えてみてほしい

2021/01/14
written by 西永
