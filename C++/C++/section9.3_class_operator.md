# operatorのoverload

operator:(和訳)演算子

要するに演算子のオーバーロード

演算子はみんなが知っている`+`や`-`などのこと  
足し算の記号として扱っていたが、これを使うと別の定義に置き換えることができる

ちなみに演算子のオーバーロードのオーバーロード対象となる演算子は算術演算子だけにとどまらない  
`()`や`=`、`+=`でも使える

そして何より、**絶対に演算子の意味に沿った実装をするべきである**

## オーバーロードの例

```C++
#include<array>

class vector_2d{
    std::array<double, 2> vec;
public:
    
    vector_2d(double num1, double num2){
        vec[0] = num1;
        vec[1] = num2;
    }

        double operator [](int i)const{
        return vec[i];
    }

    vector_2d operator +(const vector_2d&vec_plus)const{
        vector_2d vec_equal((*this)[0] + vec_plus[0], (*this)[1] + vec_plus[1]);
        return vec_equal;
    }
};

int main(){
    vector_2d vec1(3.4, 43.234);
    vector_2d vec2(12.3, -43.2);

    double d1 = vec1[0];//3.4
    double d2 = vec2[1];//-43.2

    vector_2d vec3 = vec1 + vec2;
}
```

二次元ベクトルの加法について書いた  
こうして`vector_2d`型の変数についての加算はベクトルの成分それぞれの要素を足している

`[]`でベクトルの要素にアクセスできるようにオーバーロードしている

演算子のオーバーロードは本当に様々な演算子に対して適用できる

また、引数を取ることもできるのでその時はメソッドと同じように書くとよい

これもメソッドの一種なので、section9.1で説明したようにファイル分割を用いて記述することもできる

### this

インスタンス自身のことを指し示すポインタ

`this->(変数やメソッド)`といったように自身のメンバにアクセスできる

かなり見やすくなるので重宝する

のちの継承の内容に入るが、thisポインタは派生クラスの先で呼び出される場合、派生クラスのthisポインタが暗黙的に第一引数に渡されることになっている

### constメソッド

メソッドに`const`を付けるとオブジェクトの持つメンバ変数を変更できなくなる  
`member_function()const{`といった風に使う

この時の注意は非`const`メソッドを`const`メソッドで呼び出すとコンパイルエラーになる点  
`const`メソッドなのに呼び出したメソッドで変数を書き換えてしまう可能性があるからである

## クラス外の演算子のオーバーロード

クラス外に記述してもまったく問題ないよという話

異なるクラスのオーバーロードで使うくらいなので、同じクラス、または一つのインスタンス単体でオーバーロードを使うならばクラス内で定義してほしい

また、クラス外で作ったオーバーロードはprivateにアクセスできなくなるのでそこも注意しなければならない

2021/12/23
written by 西永
