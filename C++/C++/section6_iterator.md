# イテレータ

## イテレータとは

反復子とも呼ばれるコンテナ型にアクセスするためのポインタのようなもの  

配列やarray, vectorでは先頭の要素から順番に、最後まで隙間なく並べられている

このようなアクセスはポインタだけで十分である

しかし、ほかのコンテナ型だと最初から最後まで隙間なく並んでいないことがある[^1]  
こうなるとポインタを使った数値へのアクセスはできなくなってしまう

そのため、きちんとアクセスするためにイテレータを使う

[^1]: list型など

## イテレータの使い方

### 宣言

```C++
std::vector<int>vec = {1, 2, 3};

//vecの先頭を示すイテレータ 2例
std:::vector::iterator itr1;
itr1 = vec.begin();

std:::vector::iterator itr2 = vec.begin();

//最後の要素をしめすイテレータ
std::vector::iterator itr3 = vec.end();
```

>begin関数、end関数はそれぞれコンテナクラスの先頭要素、最後の要素を取得するのに使われる  
vectorクラスだけでなくarrayクラスでも使えるし、基本的にどんなコンテナ型で使える

```C++
std::vector<int> vec = {1, 2, 3, 4, 5};
std::vector<int>::iterator itr = vec.begin();

//itrが指す要素を表示
//1
std::cout << *itr << std::endl;

//次の要素に移動
itr++;

//2
std::cout << *itr << std::endl;

//前の要素に移動
itr--;

//1
std::cout << *itr << std::endl;

//3つ後ろの要素に移動
itr += 3;

//4
std::cout << *itr << std::endl;
```

## 注意点

ポインタとは完全に一緒とはいかないので注意が必要

### 移動方法の制限

コンテナ型によっては後ろにしか移動できないイテレータ、前にしか移動できないイテレータが存在している  
後ろにしか移動できないタイプは`itr--`といった方法で前に戻ることはできない

また、ランダムアクセスできないイテレータも存在する  
このタイプは`itr + 3`といった方法で移動することはできず、`itr++` や`itr--`といった方法でしか移動が許されていない

これらの違いはコンテナ型の特徴に由来し、配列やvectorなどよりも不便だと感じても、特定の用途では配列やvectorなどよりも便利に扱えることがある

今まで紹介したコンテナ型はすべての移動方法が可能なのである

### イテレータ同士の互換性はない

扱うデータ型が同じでもコンテナ型が異なるとそのイテレータ同士は互換性がない
int型arrayクラスのイテレータとint型vectorクラスのイテレータはそれぞれ別物と考えて良い

### 要素数を変えた時の注意

arrayクラスを除き、コンテナ型は値の削除は自由に行えるが、気を付けないとバグのあるコードを書いてしまう

vectorクラスでは途中の要素を削除すると後ろのデータや今削除したデータをさしているイテレータは当然正しく使えなくなる

```C++
//エラーの出るコード

std::vector<int> vec = {1, 2, 3, 4, 5};
std::vector<int>::iterator itr = vec.begin();

++itr;
vec.erase(itr);

//ここでエラー
std::cout << *itr << std::endl;
```

反対にinsert関数やpush_back関すなどで要素を増やした場合、確保していたメモリ領域が足りなくなると別の領域にメモリを確保し、結局アドレスが変わるのでイテレータも無効になる

insert関数やerase関数など、要素のアドレスが変わるような関数はイテレータを戻り値に使うものもあるのでそれを活用すればエラーを防げるようになる

```C++
std::vector<int> vec = {1, 2, 3, 4, 5};
std::vector<int>::iterator itr = vec.begin();

itr++;
//戻り値をイテレータに代入
itr = vec.erase(itr);

//正常に表示可能
std::cout << *itr << std::endl;
```

他のコンテナクラスでも要素数をいじるとイテレータが無効になることが多いので気を付ける

## 補足

イテレータの型に関して、C++11以降ではauto型を使うことが多い  
auto型は型推論といい、自動でその変数の型を判別して適切な型に変換してくれるすごい奴だ  
詳しい話については別の機会にするが、イテレータの型は長いのでautoを使うことですっきりと記述することができる

```C++
std::vector<int> vec = {1, 2, 3, 4, 5};
auto itr = vec.begin();//これでint型のvectorクラスのイテレータの宣言ができている
```

2021/12/05
written by 西永
