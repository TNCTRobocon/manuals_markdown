# vector

配列を扱うためのコンテナ型  
vectorもその一つだがより便利に扱えるのがvectorクラスだ

vectorクラスを使用するには `#include<vector>`を記述する

vectorクラスの特徴は要素数が可変だということ  
動的配列や可変長配列と呼ばれる  
要素数を必要に応じて自由に増減させることができるので便利(配列などよりも少し遅いため要素数が決まっている場合はarrayクラスを使う方がよい

)

## 宣言と初期化

使うときの宣言はこのようにします

```c++
std::vector<int> vec{1, 2, 3}
```

初期化をしない場合はそれぞれの要素の値は不定です

宣言と初期化を同時にやるには以下のようにする

```c++
std::vector<int> vec1{1, 2, 3, 4, 5};
std::vector<int> vec2 = {1, 2, 3};

std::vector<int> vec3(100);//要素数100、すべてに0をセット

std::vector<int> vec4 (100, 1);//要素数100、すべてを1にセット

std::vector<int> vec5(vec1);//配列のコピー
```

## 代入操作

vectorの代入は配列より直感的で簡単でわかりやすい

```C++
std::vector<int>vec1 = {1, 2, 3};
std::vector<int> vec2;

vec2 = vec1;//コピー完了
```

vectorクラスでは=によって代入が可能  
arrayと同じ

ポインタを使った移動でもないのでこの後書き換えても他の変数に影響を及ぼすなんてことはないのもarrayと同様

arrayと同じく全要素のコピーなのでポインタでの受け渡しよりも時間がかかる
計算量はO(n)[^1]

[^1]: 計算量の詳しい話../../others/computational_comlexity/computational_complexity.mdを参照

## 各要素へのアクセス

```C++
std::vector<int> vec = {1, 2, 3};

vec[0]  = 10;
//vec = {10, 2, 3} となっている

```

配列とまったく同じであるので詳しい説明などは省略する

範囲外アクセスには気を付ける

気になるならばat関数を使うとよい

```C++
std::vector<int> vec = {1, 2, 3};

vec.at(0)  = 10;
```

## 二次元配列

```c++
std::vector<std::vector<int, 3>, 2> vec_2d{
    {1, 2, 3},
    {4, 5, 6},
};

//指定方法
vec_2d[2][1];
```

arrayと同じで
使い方は配列とほぼ同じ  
注意点などはsection4を参照

## 関数

### size関数

要素数の取得に使う

```C++
std::vector<int> vec = {1, 2, 3};

vec.size();//3
```

### front関数、back関数

基本的にはarrayとほぼ同じ  
ここでは省略する

### push_back関数、emplace_back関数

vectorの末尾に新しい要素を追加する  
この二つはどちらとも同じような動作をする  

emplace_backのほうが高速に動作することが多い

>細かい内部動作についてはクラスについての理解が必要なのでここでは省略する  
気になったら自分で調べてほしい

### insert関数

vectorの途中にデータを追加する時に使う

```c++
std::vector<int> vec = {1, 2, 3};

vec.insert(vec.begin()+1, 10);//1, 10, 2, 3
```

2番目の位置に数字を挿入した  
第一引数のところはイテレータを利用している(section6を参照)

insert関数は任意の場所にデータを挿入できるが、vectorは**末尾への要素追加は高速だが途中への要素追加は低速**
という特徴がある  
何度も挿入を行うなら最初からそれも考えてコードを書くか、任意位置への挿入が高速なクラスがあるのでそれを利用するとよい  
イテレータを使えばinsert関数でvectorの挿入も可能、section6で説明する

emplace関数もあるので調べるとよい

### pop_back関数

末尾要素の削除

```C++
std::vector<int> vec = {1, 2, 3};

vec.popback();//1, 2
```

末尾の要素の削除は高速に動作する  
しかし、メモリ上で存在しているサイズは減少しないので注意  
メモリを解放する方法は後述

### erase関数

途中の要素を削除できる
insert関数と同じく途中の要素の削除は少し低速になる

```C++
std::vector<int> vec1 = {1, 2, 3, 4, 5};

//1 3 4 5
vec.erase(vec.begin() + 1);

std::vector<int> vec2 = {1, 2, 3, 4, 5};

//1 5
vec.erase(vec.begin() + 1, vec.end() - 1);
```

イテレータを利用して削除している
今はこういうものだと思ってほしい

vec1は要素を一つだけ削除、vec2は要素を範囲を指定して削除する

これもpop_back関数と同じくメモリは解放されない

### clear関数

```C++
std::vector<int> vec  ={1, 2, 3};

vec.clear();//vecを空にする
```

要素をすべて削除する

これもメモリは解放されない

### swap関数

vector同士の入れ替え

arrayと同じように使える  
省略する

### resize関数

要素数の変更のために使う

```c++
std::vector<int> vec = {1, 2, 3};

//要素の拡張
vec.resize(5);//1, 2, 3, 0, 0

//要素の縮小
vec.siaze(2);//1,2

//要素を拡張して指定した値で埋める
vec.resze(5, 10);//1, 2, 10, 10, 10
```

要素数を拡張したら要素は指定しなければ0で埋められる

要素を削除してはみ出した分は削除される

削除系関数と同じく確保されたメモリは解放されない

### assign関数

fill関数のvector版  
メモリを拡張してそこも埋めることができるなどできることが増えている

```c++
std::vector<int> vec1 = {1, 2};
std::vector<int> vec2 = {1, 2};
std::vector<int> vec3 = {1, 2, 3, 4, 5};

//5個の9で埋める
vec1.assign(9, 5);//9 9 9 9 9

//リストで埋める
vec2.assign({ 9, 8, 7, 6, 5 });//9 8 7 6 5

//他のvectorの範囲で埋める
vec3.assign(vec2.begin() + 1, vec2.end() - 1);//8 7 6
```

これもメモリの解放はされないので注意

### reserve関数

何回もメモリを確保するとメモリの確保がそれなりに重い処理なのでパフォーマンスに影響が出ることがある  
そこで前もってメモリを確保しておく関数がこれである

### capacity関数

現在確保しているメモリのサイズを返す  
size関数は現在の要素数を返すが、capacity関数はメモリの要素数(size)を返す

### shrink_to_fit関数

実際の要素数とメモリ上の要素数が合わなくなった時に巨大なvectorなどを空にしたい場合など、メモリを解放したい場合に使う

2021/12/04  
written by 西永
