# ラムダ式

~~ラムダ式って強そうだよね~~

簡易的な関数オブジェクトをその場で定義する機能

もっとも簡単なラムダ式を示す

```C++
[]{};
```

[]はラムダ式の(キャプチャという)記号で、その中にパラメータを設定するが後で解説する  
関数定義でおなじみの{}を付けておわり  
実際のラムダ式の定義はこの中に書く

オブジェクトを識別、アクセスする名前を持たない関数を無名関数という

## 関数の呼び出し

さっきの最小のラムダ式では関数を定義しただけなので実行できていない

ラムダ式をそのまま呼び出すには

```C++
[]{}();
```

のように最後に丸括弧を付けてあげれば定義してそのまま呼び出せる

## 名前を付ける

名前を付ければ他の関数に近い使い方が可能になる

型名は`auto`型か`std::function`を使う
>`std::function`は`functional`をインクルードする必要がある

```C++
auto func1 = []{std::cout<<"lambda"<<std::endl;};
func1();//lambda

std::function<void()> func2 = []{std::cout << "lambda" << std::endl;};
func2();
```

このどちらかを使うとよい

使い方としては関数ポインタのように扱えるので便利
>実際、関数ポインタでキャプチャを持たないラムダ式は受け取れてしまう

## 引数

ラムダ式に引数を指定するときには[]の後に()を記述し、そこに引数を指定する  
記述も呼び出しも関数のと変わらずに行える

ただし、パラメータにテンプレートは使用することはできないので注意

```C++
auto func = [](int i, int j){std::cout << (x+y) << std::endl;};
//または
std::function<void(int, int)> func = [](int i, int j){std::cout << (x+y) << std::endl;};

func(2, 3);//5
```

## 戻り値

```C++
auto func1 = [](int i, int j) {return i + j;};

auto func2 = [](int i, int j) -> int {return i + j;};

std::function<int(int, int)> func3 = [](int i, int j) {return i + j;};
```

最後にアロー演算子を使えば戻り値のデータ型の指定ができる

## 変数のキャプチャ

ラムダ式は関数内に記述されるが、ラムダ式のブロック内は独立したスコープとなっていてラムダ式の外の変数にアクセスすることはできない

ブロック外の変数にアクセスするには引数で受け取る他に変数のキャプチャという機能を使用することができる

|キャプチャ記法|説明|
|-|-|
|`[&]`|外部の変数を参照してラムダ式の中で使用する|
|`[=]`|外部の変数をコピーしてラムダ式の中で使用する|
|`[&x]`|変数`x`を参照してラムダ式の中で使用する|
|`[=x]`|変数`x`をコピーしてラムダ式の中で使用する|
|`[&, x]`|デフォルトで参照キャプチャ、`x`のみコピー|
|`[=, &x]`|デフォルトでコピー、`x`のみ参照|
|`[this]`|`*this`のメンバを参照してラムダ式の中で使用する|
|`[this, x]`|`*this`メンバを参照し、変数`x`のみ参照|

```C++
void hoge(){
    int i = 0, j = 1, k = 2;

    auto f1 = [&]{
        i = j + k;
        return i;
    };

    auto f2 = [=]{
        return i + j + k;
    };
}
```

`f1`ではキャプチャで&が指定されていて、iの値が3に書き変わってしまう

よって`f2`の戻り値の値は6である  
また、キャプチャの指定で`=`を指定したときはそのままでは変数の書き換えは不可能であるので注意

```C++
void hoge(){
    int i = 0, j = 1, k = 2;

    auto f1 = [&, i]{
        //略
    };

    auto f2 = [=, i]{
        //略
    };

    auto f3 = [i, &j]{
        //略
    }
}
```

最初のラムダ式は`i`をコピーで、それ以外は参照で受け取るもの  
二番目のラムダ式は`i`を参照で、それ以外をコピーで受け取るもの  
最後のラムダ式は`i`をコピーで、`j`を参照で、`k`を受け取れなくした変数

```C++
class hoge{
    int private_i = 0;

public:
    int public_i = 1;
    int copy = 2;

    auto func = [this, copy]{
        std::cout<<public_i<<std::endl;
        std::cout<<private_i<<std::endl;
    };

}
```

privateメンバやpublicメンバのどちらにもアクセスできる
>`this`クラスの`friend`という扱いになるのでアクセスできている

それとあくまでも`this`経由なので値を書き換えるとメンバ変数の値が書き変わるので注意

## mutable

column1で出てきた`mutable`君(constメソッドの辺り)

ラムダ式でも活躍する

実はラムダ式でキャプチャを`=`で指定した場合、変数の書き換えが不可能となっている  
なのでmutableをつかってラムダ式の内部で書き換えようという話  

ちなみに、コピーなので変数を書き換えてももとの変数の値は変わらない

```C++
int hoge(){
    int i = 0, j = 1, k = 2;
    auto f = [=] mutable {
        i = j + k;
        return i;
    }();
}
```

## ラムダ式を引数で受け取る

いよいよ関数ポインタみたいになってきた

```C++
template<class T>
void call_func(T func){
    func(1, 2);
}

int main(){
    auto func = [](int i, int j){
        return i+j;
    };

    call_func(func);
}
```

`template`を使う方法

## 関数ポインタとして扱う

キャプチャを含まなければ同じパラメータを持つ関数ポインタに変換できる

std::functionを使う方が圧倒的に楽であるが一応

```C++
void call_func(int(*fp)(int, int)){
    func(1, 2);
}

int main(){
    int(*function_pointer)(int, int) = [](int i, int j){
        return i+j;
    };

    call_func(function_pointer);
}
```

2021/01/17
written by 西永
